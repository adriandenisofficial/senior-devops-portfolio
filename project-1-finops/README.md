Project 1: FinOps Observability PipelineRole: Cloud Engineer & FinOps PractitionerStatus: ‚úÖ Deployed & VerifiedFocus: Cost Intelligence, Monitoring, & Automationüìñ Executive SummaryThis project bridges the gap between Engineering Health (Latency/Errors) and Business Impact (AWS Spend/Revenue).In standard DevOps environments, "Cost" is often a lagging indicator‚Äîa bill received at the end of the month. I engineered a solution to make cost a leading indicator, allowing teams to see the financial impact of their infrastructure changes in real-time alongside system performance metrics.üèóÔ∏è ArchitectureThe system follows a Scrape-Based Architecture:Application Layer: A Flask Microservice instrumented with prometheus_client to expose business metrics (Revenue per Second).Infrastructure Layer: A custom Python exporter using boto3 to fetch real-time billing data from AWS Cost Explorer.Aggregation Layer: Prometheus scrapes both the App and the Cost Exporter every 15 seconds.Visualization Layer: Grafana correlates these metrics on a unified dashboard.üõ† Tech StackComponentTechnologyPurposeOrchestrationDocker ComposeManaging the multi-container stack.App LogicPython (Flask)Simulating high-traffic e-commerce transactions.Cloud SDKAWS Boto3Programmatic access to AWS Cost Explorer API.Metric StoragePrometheusTime-series database for storing cost & latency data.VisualizationGrafanaDashboarding "Cost per Request" vs. "Latency".SecurityAWS IAMLeast Privilege Roles (Read-Only access to Billing).üõ°Ô∏è Key Engineering Decisions1. The "Sidecar" Pattern for Cost InjectionChallenge: Standard tools like node-exporter only measure CPU/RAM, not money.Solution: I wrote a custom Python Sidecar Container. It runs alongside the application, independently authenticating with AWS to fetch billing data and formatting it into OpenMetrics standards.Benefit: Decouples cost monitoring from application logic. The app doesn't need to know about AWS credentials.2. Custom Prometheus InstrumentationChallenge: Measuring "HTTP 200 OK" is not enough to understand business health.Solution: I instrumented the application code to expose Business Metrics:app_revenue_total: Counter metric tracking real-time dollars generated.app_requests_processing_seconds: Histogram metric tracking 99th percentile latency.Result: We can now alert if Revenue drops even if Server Health is green (logic error detection).3. Least-Privilege IAM SecurityChallenge: Giving a container access to AWS Billing is risky.Solution: Instead of using Admin keys, I created a restricted IAM Policy allowing only ce:GetCostAndUsage.Benefit: Even if the container is compromised, the attacker cannot provision resources or read sensitive S3 data.üì∏ Evidence & DashboardsThe "Single Pane of Glass"This Grafana dashboard correlates three critical dimensions:System Health: (Top Left) Latency and Error Rates.Business Health: (Top Right) Revenue generated per second.Financial Health: (Bottom) Real-time AWS Daily Spend.(Place your Screenshot Here)üíª How to Run This ProjectPrerequisitesDocker Desktop installed.AWS Account with Cost Explorer enabled.AWS Credentials (~/.aws/credentials) or IAM Role attached to the host.Step-by-Step Deployment1. Clone the RepositoryBashgit clone https://github.com/adriandenisofficial/senior-devops-portfolio.git
cd senior-devops-portfolio/project-1-finops
2. Configure PermissionsPrometheus needs permission to write metric data to the local volume.Bashchmod -R 777 prom_metrics
3. Inject AWS Credentials (Local Mode)Note: In production, use IAM Roles. For local testing, mount your credentials.YAML# Inside docker-compose.yml (already configured)
volumes:
  - ~/.aws:/root/.aws:ro
4. Launch the StackBashdocker-compose up -d --build
5. Generate TrafficI included a traffic simulator script to populate the graphs.Bashpython3 traffic_generator.py
6. Access the DashboardGrafana: http://localhost:3000Login: admin / adminPrometheus: http://localhost:9090üßπ Tear DownTo stop the stack and remove volumes:Bashdocker-compose down -v
